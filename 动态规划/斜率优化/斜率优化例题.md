# 斜率优化例题

## 问题：acwing 303.运输小猫

原本公式 : fj,i = min( fj-1,k + (i - k) * ai - ( si - sk ) )

将fj-1,k + sk看成y，ai看成斜率，则是第一种斜率优化题型。

```cpp
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10, M = 1e5 + 10, P = 105;

LL d[N], h, t[M], s[M], q[M], a[M];
LL f[P][N];
int n, m, p;

LL get(int j,int k)
{
    return f[j-1][k] + s[k];
}

int main()
{
    scanf("%d%d%d", &n, &m, &p);
    
    for(int i = 2; i <= n; i ++)
    {
        scanf("%lld", &d[i]);
        d[i] += d[i - 1];
    }
    
    for(int i = 1; i <= m; i ++) 
    {
        scanf("%lld%lld", &h, &t[i]);
        a[i] = t[i] - d[h];
    }
    
    sort(a + 1, a + m + 1);
    
    for(int i = 1; i <= m; i ++) s[i] = s[i - 1] + a[i];
    
    memset(f, 0x3f, sizeof f);
    for(int i = 0; i <= p; i ++)f[i][0] = 0;
    
    for(int j = 1; j <= p; j ++)
    {
        int hh = 0, tt = 0;
        q[0] = 0;
        for(int i = 1; i <= m; i ++)
        {
            while(hh < tt && a[i] * (q[hh + 1] - q[hh]) >= get(j, q[hh + 1]) - get(j, q[hh])) hh ++;
            int k = q[hh];
            f[j][i] = f[j - 1][k] + s[k] - a[i] * k - s[i] + i * a[i];
            while(hh < tt && (get(j, q[tt]) - get(j, q[tt - 1])) * (i - q[tt]) >= (get(j, i) - get(j, q[tt])) * 
            (q[tt] - q[tt - 1])) tt --;
            q[++ tt] = i;
        }
    }
    cout << f[p][m] << endl;
    
    return 0;
}
```



## **一.【理解方式】**

以 [**【模板】** 玩具装箱 toy [P3195\]toy [P3195]](https://www.luogu.org/problemnew/show/P3195) 为例，两种斜优的理解方式。

设 �[�]=∑�=1�(�[�]+1)*S*[*n*]=∑*i*=1*n*(*C*[*i*]+1)，用 ��[�]*d**p*[*i*] 表示装好前 �*i* 个的最小花费，则转移方程为：��[�]=min⁡(��[�]+(�[�]−�[�]−1−�)2)*d**p*[*i*]=min(*d**p*[*j*]+(*S*[*i*]−*S*[*j*]−1−*L*)2)。

为方便描述，将 LL 提前加 11，再把 min⁡min 去掉，得到状态转移方程：��[�]=��[�]+(�[�]−�[�]−�)2*d**p*[*i*]=*d**p*[*j*]+(*S*[*i*]−*S*[*j*]−*L*)2。

化简得：��[�]=�[�]2−2�[�]�+��[�]+(�[�]+�)2−2�[�]�[�]*d**p*[*i*]=*S*[*i*]2−2*S*[*i*]*L*+*d**p*[*j*]+(*S*[*j*]+*L*)2−2*S*[*i*]*S*[*j*]

### **1.【代数法（数形结合）】**

只含 LL 的项对于每一个 �*i* 的**择优筛选**过程都是完全一样的值，只含 ��������(�)*F**u**n**c**t**i**o**n*(*i*) 的项在一次 �*i* 的**择优筛选**过程中不变，含 ��������(�)*F**u**n**c**t**i**o**n*(*j*) 的项可能会不断变化（在本题中表现为为**严格单增**）。
我们以此为划分依据，把同类型的项用括号括起来，即：��[�]=(−2�[�]�[�])+(��[�]+(�[�]+�)2)+(�[�]2−2�[�]�)*d**p*[*i*]=(−2*S*[*i*]*S*[*j*])+(*d**p*[*j*]+(*S*[*j*]+*L*)2)+(*S*[*i*]2−2*S*[*i*]*L*)

#### **(1).【维护一个凸包】**

设 �1,�2*j*1,*j*2 (0⩽�1<�2<�)(0⩽*j*1<*j*2<*i*) 为 �*i* 的两个决策点，且满足**决策点 �2\*j\*2 优于 �1\*j\*1**， 有：(−2�[�]�[�2])+(��[�2]+(�[�2]+�)2)+(�[�]2−2�[�]�)⩽(−2�[�]�[�1])+(��[�1]+(�[�1]+�)2)+(�[�]2−2�[�]�)(−2*S*[*i*]*S*[*j*2])+(*d**p*[*j*2]+(*S*[*j*2]+*L*)2)+(*S*[*i*]2−2*S*[*i*]*L*)⩽(−2*S*[*i*]*S*[*j*1])+(*d**p*[*j*1]+(*S*[*j*1]+*L*)2)+(*S*[*i*]2−2*S*[*i*]*L*)

即：(−2�[�]�[�2])+(��[�2]+(�[�2]+�)2)⩽(−2�[�]�[�1])+(��[�1]+(�[�1]+�)2)(−2*S*[*i*]*S*[*j*2])+(*d**p*[*j*2]+(*S*[*j*2]+*L*)2)⩽(−2*S*[*i*]*S*[*j*1])+(*d**p*[*j*1]+(*S*[*j*1]+*L*)2)

**划重点：此处移项需要遵循的原则是：参变分离。将 ��������(�)\*F\**u\**n\**c\**t\**i\**o\**n\*(\*i\*) 视作未知量，用 ��������(�)\*F\**u\**n\**c\**t\**i\**o\**n\*(\*j\*) 来表示出 ��������(�)\*F\**u\**n\**c\**t\**i\**o\**n\*(\*i\*) 。**

> 移项得：−2�[�](�[�2]−�[�1])⩽(��[�1]+(�[�1]+�)2)−(��[�2]+(�[�2]+�)2)−2*S*[*i*](*S*[*j*2]−*S*[*j*1])⩽(*d**p*[*j*1]+(*S*[*j*1]+*L*)2)−(*d**p*[*j*2]+(*S*[*j*2]+*L*)2)
> ∵�[�]⩾1∵*C*[*j*]⩾1
> ∴�[�+1]>�[�]∴*S*[*j*+1]>*S*[*j*]
> 又∵�2>�1又∵*j*2​>*j*1​
> ∴�[�2]−�[�1]>0∴*S*[*j*2​]−*S*[*j*1​]>0
> ∴2�[�]⩾(��[�2]+(�[�2]+�)2)−(��[�1]+(�[�1]+�)2)�[�2]−�[�1]∴2*S*[*i*]⩾*S*[*j*2​]−*S*[*j*1​](*d**p*[*j*2​]+(*S*[*j*2​]+*L*)2)−(*d**p*[*j*1​]+(*S*[*j*1​]+*L*)2)​
> 设 �(�)=��[�]+(�[�]+�)2,�(�)=�[�]*Y*(*j*)=*d**p*[*j*]+(*S*[*j*]+*L*)2,*X*(*j*)=*S*[*j*]， 即 2�[�]⩾�(�2)−�(�1)�(�2)−�(�1)2*S*[*i*]⩾*X*(*j*2​)−*X*(*j*1​)*Y*(*j*2​)−*Y*(*j*1​)​

显然等式右边是一个关于点 �(�2)*P*(*j*2) 和 �(�1)*P*(*j*1) 的斜率式，其中 �(�)=(�(�),�(�))=(�[�],��[�]+(�[�]+�)2)*P*(*j*)=(*X*(*j*),*Y*(*j*))=(*S*[*j*],*d**p*[*j*]+(*S*[*j*]+*L*)2)。

也就是说，如果存在两个决策点 �1,�2*j*1,*j*2 满足 (0⩽�1<�2<�)(0⩽*j*1<*j*2<*i*)，使得不等式 �(�2)−�(�1)�(�2)−�(�1)⩽2�[�]*X*(*j*2)−*X*(*j*1)*Y*(*j*2)−*Y*(*j*1)⩽2*S*[*i*] 成立，或者说 使得 �(�2),�(�1)*P*(*j*2),*P*(*j*1) 两点所形成直线的斜率小于等于 2�[�]2*S*[*i*]，那么**决策点 �2\*j\*2 优于 �1\*j\*1**。

> **划重点：斜优灵活多变，细节麻烦也多，所以尽量将问题模式化。**
> 比如这里的最终公式，尽量化为 (�)−(�′)(�)−(�′)(*j*)−(*j*′)(*j*)−(*j*′)​ 的形式，而不是 (�)−(�′)(�′)−(�)(*j*′)−(*j*)(*j*)−(*j*′)​ ，虽然直接做一般也不会出什么问题，但这样子可以方便理解，方便判断凸包方向等等。

假设有酱紫的三个点 �(�1),�(�2),�(�3)*P*(*j*1),*P*(*j*2),*P*(*j*3)，�1,�2*k*1,*k*2 为斜率，如下图所示情况（三点分别为 �,�,�*A*,*B*,*C*）：

![img](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_464656465.PNG)

显然有 �2<�1*k*2<*k*1。设 �0=2�[�]*k*0=2*S*[*i*]，由上述结论可知：

> (�).(*a*). 若 �1⩽�0*k*1⩽*k*0，则 �2*j*2 优于 �1*j*1 。反之，若 �1>�0*k*1>*k*0，则 �1*j*1 优于 �2*j*2 。
> (�).(*b*). 若 �2⩽�0*k*2​⩽*k*0​，则 �3*j*3​ 优于 �2*j*2​ 。反之，若 �2>�0*k*2​>*k*0​，则 �2*j*2​ 优于 �3*j*3​ 。

于是这里可以分三种情况来讨论：

> (1).(1). �0<�2<�1*k*0<*k*2<*k*1。由 (�),(�)(*a*),(*b*) 可知：�1*j*1 优于 �2*j*2 优于 �3*j*3 。
> (2).(2). �2⩽�0<�1*k*2​⩽*k*0​<*k*1​。由 (�),(�)(*a*),(*b*) 可知：�1*j*1​ 和 �3*j*3​ 均优于 �2*j*2​。
> (3).(3). �2<�1⩽�0*k*2​<*k*1​⩽*k*0​。由 (�),(�)(*a*),(*b*) 可知：�3*j*3​ 优于 �2*j*2​ 优于 �1*j*1​ 。

可以发现，对于这三种情况，�2*j*2 **始终不是最优解**，于是我们可以**将 �2\*j\*2 从候选决策点中踢出去（删除）**，只留下 �1*j*1 和 �3*j*3，删后的情况如下图所示：

![img](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_456.PNG)

我们要对某一个问题的解决方案进行优化改进，无非就是关注两个要点：**正确性**和**高效性**（很多时候**高效性**都体现为**单调性**）。

酱紫做的**正确性**是毋庸置疑的，因为在 �1*j*1 和 �3*j*3 其中必定有一个比 �2*j*2 更优，所以删除 �2*j*2 对答案没有任何影响。

那么**高效性**呢？自己在脑子里面 ��*y**y* 一下，在一个坐标系的第一象限中（本题中 �(�)*X*(*j*) 和 �(�)*Y*(*j*)均大于等于 00，至于为什么这里要说等于，下面会提到），有若干个离散的点，任取三点，如果左边斜率大于右边斜率，则形成了上述情况，必定会删点，因而消除这种情况。所以**将最后留下来的点首位相连，其形成的各个线段斜率从左到右必定是单调递增的**（有可能非严格递增，这个问题之后再讨论）。

如果学习过计算几何相关知识，会意识到这个过程其实与求凸包算法是类似的。（顺手丢一个广告：[【学习笔记】计算几何全家桶](https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-ji-suan-ji-he-quan-jia-tong)）

实际上在图中选取最靠左下面、下面、右下面的点首位相连，就是最后留下来的点了，它们形成了一个**下凸包**，即**凸包**（又名**凸壳**）的**下半部分**（不严谨的讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的**凸多边形**，它能包含点集中所有的点——摘自[百度百科](https://baike.baidu.com/item/凸包/179150?fr=aladdin)）。

维护出的图形如下图所示：

![img](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_789.PNG)

可以尝试在凸包围起来的区域内任意取一点，其必定能在包围圈上找到两个点使得该点可被删除。如上 LL 点，它与 �,�*D*,*E* 两点形成了一个可删点图形。

> 注意：图中 �,�,�*C*,*D*,*E* 故意画成了三点一线，而实际上点 �*D* 是可以删去的，且严格凸包不允许存在这种情况。关于去重的细节问题后面会提到。

**同理**，如果把不等式 �(�2)−�(�1)�(�2)−�(�1)⩽�0[�]*X*(*j*2)−*X*(*j*1)*Y*(*j*2)−*Y*(*j*1)⩽*k*0[*i*] 改为 �(�2)−�(�1)�(�2)−�(�1)⩾�0[�]*X*(*j*2)−*X*(*j*1)*Y*(*j*2)−*Y*(*j*1)⩾*k*0[*i*]，那么维护出来的就是一个**上凸包**。

#### **(2).【寻找最优决策点】**

在一次决策点的寻找中，易知下凸包点集里总会存在一点，使得它与左邻点形成的斜率小于等于 �0*k*0 ，与右邻点形成的斜率大于 �0*k*0 。

例如上图中的 �*E* 点，设 �4⩽�0<�5*k*4⩽*k*0<*k*5 由于凸包上面的斜率呈单增态，那么有：�1<�2<�3<�4⩽�0<�5<�6<�7*k*1<*k*2<*k*3<*k*4⩽*k*0<*k*5<*k*6<*k*7，所以决策点 �*E* 优于其他所有点，即 �*E* 就是 ��[�]*d**p*[*i*] 的**最优决策点**。

如果暴力查找的话，就是从第一个点开始向后扫描，找到**第一个斜率大于 �0\*k\*0 的线段**，其左端点即为**最优决策点**。由于凸包上的斜率依次递增，可以**二分**快速得到这个点。

### **2.【线性规划】**

先回顾一下模板题的 dpdp 方程：��[�]=�[�]2−2�[�]�+��[�]+(�[�]+�)2−2�[�]�[�]*d**p*[*i*]=*S*[*i*]2−2*S*[*i*]*L*+*d**p*[*j*]+(*S*[*j*]+*L*)2−2*S*[*i*]*S*[*j*]。

对其进行移项变化，变成形如 �=��+�*y*=*k**x*+*b* 的点斜式。
**划重点：移项要遵循的原则是：把含有 ��������(�)∗��������(�)\*f\**u\**n\**c\**t\**i\**o\**n\*(\*i\*)∗\*f\**u\**n\**c\**t\**i\**o\**n\*(\*j\*) 的表达式看作斜率 �0\*k\*0​ 乘以未知数 �\*x\*，含有 ��[�]\*d\**p\*[\*i\*] 的项必须要在 �\*b\* 的表达式中，含有 ��������(�)\*f\**u\**n\**c\**t\**i\**o\**n\*(\*j\*) 的项必须在 �\*y\* 的表达式中。如果未知数 �\*x\* 的表达式单调递减，最好让等式两边同乘个 −1−1，使其变为单增**。

至于为什么说要让 �*x* 的表达式单增，emm...其实是为了让一些较简单的问题模式化，不易出错，如果你非要单减，可以尝试倒序枚举，至于是否正确，具体实现需要注意的玄学问题等等，因为觉得太麻烦没有细想，我也不清楚会遇到什么问题。

例如此题，原 dpdp 方程可化为： (2�[�])�[�]+(��[�]−�[�]2+2�[�]�)=(��[�]+(�[�]+�)2)(2*S*[*i*])*S*[*j*]+(*d**p*[*i*]−*S*[*i*]2+2*S*[*i*]*L*)=(*d**p*[*j*]+(*S*[*j*]+*L*)2)

其中 ��=2�[�],*k**i*=2*S*[*i*], ��=�[�],*x**i*=*S*[*j*], ��=��[�]−�[�]2+2�[�]�,*b**i*=*d**p*[*i*]−*S*[*i*]2+2*S*[*i*]*L*, ��=��[�]+(�[�]+�)2*y**i*=*d**p*[*j*]+(*S*[*j*]+*L*)2。

其实也可以化为： (2�[�])(�[�]+�)+(��[�]−�[�]2)=(��[�]+(�[�]+�)2)(2*S*[*i*])(*S*[*j*]+*L*)+(*d**p*[*i*]−*S*[*i*]2)=(*d**p*[*j*]+(*S*[*j*]+*L*)2) 其中 ��=2�[�],*k**i*=2*S*[*i*], ��=�[�]+�,*x**i*=*S*[*j*]+*L*, ��=��[�]−�[�]2,*b**i*=*d**p*[*i*]−*S*[*i*]2, ��=��[�]+(�[�]+�)2*y**i*=*d**p*[*j*]+(*S*[*j*]+*L*)2。

还可以化为 ......

......

只要满足上述移项原则，对答案是没有任何影响的。

这里以第一种形式为例，先画出草图：

![img](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_14564864.PNG)

#### **(1).【高中数学知识】**

我们的目的是求出一个**最优决策点** �*j* 使得 ��[�]*d**p*[*i*] 最小，又因为 �[�]=��[�]−�[�]2*b*[*i*]=*d**p*[*i*]−*S*[*i*]2 ，所以就是要找到某个点使这条直线经过它时算出来的 �*b* 最小，即是高中数学课本上的**线性规划**问题。

#### **(2).【寻找最优决策点】**

![img](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_4684.PNG)

如图所示，点 �*E* 即为**最优决策点**。显然，这个使得 �*b* 最小的**最优决策点**位于**下凸包**点集中，且与上述**代数法**求得的点一致。

### **3.【两种思考方式的结合】**

强烈推荐用**线性规划**思想主导思考过程，因为图形的变幻较直观，更重要的是：在某某变量不满足单调性时，通过图形可以迅速做出判断并改变策略（在后面【关于单调性的研究】中会详细解释）。

而**代数法**通常在不便于识别方程特征时起一个转换思维方向的作用，因为有些题可能会直接出现 �(�)−�(�′)�(�)−�(�′)*X*(*j*)−*X*(*j*′)*Y*(*j*)−*Y*(*j*′) 的形式，需要通过一系列代数推导后再绘草图模拟决策。

------

## **二.【维护凸包】**

实际上只要让维护的凸包方向相同，两种思考方式的代码是一模一样的。

用单调队列维护凸包点集，操作分三步走：
(1).(1). 进行**择优筛选**时，在凸包上找到**最优决策点** �*j* 。
(2).(2). 用**最优决策点** �*j* 更新 ��[�]*d**p*[*i*] 。
(3).(3). 将 �*i* 作为一个**决策点**加入图形并更新凸包（如果点 �*i* 也是 ��[�]*d**p*[*i*] 的**决策点之一**，则需要将 (3)(3) 换到最前面）。

在本题中步骤 (3)(3) 的具体操作为：判断当队尾的点与点 �*i* 形成可删点图形时，出队直至无法再删点，然后将 �*i* 加入队列。

在判断可删图形时有两种方法（以 下凸包 为例），一种是 `slope(Q[t-1],Q[t])<=slope(Q[t],i)`，另一种是 `slope(Q[t-1],Q[t])<=slope(Q[t-1],i)`，都表示出现了可以删去点 �[�]*Q*[*t*] 的情况（只要对边界、去重的处理足够严谨，两种写法是没有区别的）。其中 �*Q* 是维护凸包点集的队列。

该做法时间复杂度为 �(�log⁡�)*O*(*n*log*n*)，瓶颈在于二分寻找**最优决策点**。

------

## **三.【再优化】**

运用**决策单调性**进行优化。**决策单调性**相关基础知识见 **[【学习笔记】动态规划—各种 DPDP 优化](https://www.cnblogs.com/Xing-Ling/p/11317315.html)**，这里只放一下定义：
设 �0[�]*j*0​[*i*] 表示 ��[�]*d**p*[*i*] 转移的**最优决策点**，那么**决策单调性**可描述为 ∀�⩽�′,�0[�]⩽�0[�′]∀*i*⩽*i*′,*j*0​[*i*]⩽*j*0​[*i*′]。也就是说随着 �*i* 的增大，所找到的**最优决策点**是递增态（非严格递增）。

### **(1).【决策单调性证明】**

还是以 [玩具装箱](https://www.luogu.org/problemnew/show/P3195) 为例，来简单证一波决策单调性，方法采用**四边形不等式**。

显然，本题的转移方程呈现出了 ��[�]=min⁡(��[�]+�(�,�))*d**p*[*i*]=min(*d**p*[*j*]+*w*(*i*,*j*)) 的形式，即 1�/1�1*D*/1*D* 动态规划方程，其中 �(�,�)=(�[�]−�[�]−1−�)2*w*(*i*,*j*)=(*S*[*i*]−*S*[*j*]−1−*L*)2。

证明：设证明：设 �=�[�]−�[�]−1−�*Q*=*S*[*i*]−*S*[*j*]−1−*L*

∴�(�,�)=(�[�]−�[�]−1−�)2=�2∴*w*(*i*,*j*)=(*S*[*i*]−*S*[*j*]−1−*L*)2=*Q*2

∴�(�+1,�+1)=(�[�+1]−�[�+1]−1−�)2=((�[�]+�[�+1]+1)−(�[�]+�[�+1]+1)−1−�)2=(�+�[�+1]−�[�+1])2∴*w*(*i*+1,*j*+1)===(*S*[*i*+1]−*S*[*j*+1]−1−*L*)2((*S*[*i*]+*C*[*i*+1]+1)−(*S*[*j*]+*C*[*j*+1]+1)−1−*L*)2(*Q*+*C*[*i*+1]−*C*[*j*+1])2

�(�,�+1)=(�[�]−�[�+1]−1−�)2=(�[�]−(�[�]+�[�+1]+1)−1−�)2=(�−�[�+1]−1)2*w*(*i*,*j*+1)===(*S*[*i*]−*S*[*j*+1]−1−*L*)2(*S*[*i*]−(*S*[*j*]+*C*[*j*+1]+1)−1−*L*)2(*Q*−*C*[*j*+1]−1)2

�(�+1,�)=(�[�+1]−�[�]−1−�)2=((�[�]+�[�+1]+1)−�[�]−1−�)2=(�+�[�+1]+1)2*w*(*i*+1,*j*)===(*S*[*i*+1]−*S*[*j*]−1−*L*)2((*S*[*i*]+*C*[*i*+1]+1)−*S*[*j*]−1−*L*)2(*Q*+*C*[*i*+1]+1)2

∴�(�,�)+�(�+1,�+1)=2�2+2�[�+1]�−2�[�+1]�+�[�+1]2−2�[�+1]�[�+1]+�[�+1]2∴*w*(*i*,*j*)+*w*(*i*+1,*j*+1)=2*Q*2+2*C*[*i*+1]*Q*−2*C*[*j*+1]*Q*+*C*[*i*+1]2−2*C*[*i*+1]*C*[*j*+1]+*C*[*j*+1]2

∴�(�+1,�)+�(�,�+1)=2�2+2�[�+1]�−2�[�+1]�+�[�+1]2+2�[�+1]+2�[�+1]+�[�+1]2+2∴*w*(*i*+1,*j*)+*w*(*i*,*j*+1)=2*Q*2+2*C*[*i*+1]*Q*−2*C*[*j*+1]*Q*+*C*[*i*+1]2+2*C*[*i*+1]+2*C*[*j*+1]+*C*[*j*+1]2+2

∴�(�,�)+�(�+1,�+1)−�(�+1,�)+�(�,�+1)=−2(�[�+1]+1)(�[�+1]+1)∴*w*(*i*,*j*)+*w*(*i*+1,*j*+1)−*w*(*i*+1,*j*)+*w*(*i*,*j*+1)=−2(*C*[*i*+1]+1)(*C*[*j*+1]+1)

又∵�[�],�[�]⩾1又∵*C*[*i*],*C*[*j*]⩾1

∴−2(�[�+1]+1)(�[�+1]+1)⩽−8∴−2(*C*[*i*+1]+1)(*C*[*j*+1]+1)⩽−8

∴�(�,�)+�(�+1,�+1)⩽�(�+1,�)+�(�,�+1)∴*w*(*i*,*j*)+*w*(*i*+1,*j*+1)⩽*w*(*i*+1,*j*)+*w*(*i*,*j*+1)

四边形不等式成立，所以此方程具有决策单调性。
证毕。

### **(2).【单调队列】**

由于**最优决策点**递增，可以用单调队列对其进行维护。操作 (2),(3)(2),(3) 不需要改动，操作 (1)(1) 改为：判断当队首的第一根线段斜率小于等于 �0[�]*k*0[*i*] 时就出队，直至斜率大于 �0[�]*k*0[*i*]，此时的队首即为**最优决策点**。

正确性显然。因为随着 �*i* 的变大，最优决策点 �0[�]*j*0[*i*] 也会跟着变大，如果已知某个点在当前情况下不够侑秀，那么在这之后也一定不会作为最优决策点，所以可以直接出队。

时间复杂度为 �(�)*O*(*n*) 。

### **(3).【再证决策单调性】**

一样的，两种思路。

先观察 �0[�]*k*0[*i*] 的表达式：�0[�]=2�[�]*k*0[*i*]=2*S*[*i*] ，明显在本题中 �0*k*0 呈单增态。

#### **【代数法】**

�0[�]*k*0[*i*] 递增就说明我们找到的**第一个斜率大于 �0[�]\*k\*0[\*i\*] 的线段**在不断地向后移，也就是说，如果我们找到了某一个**最优决策点 �\*j\***，那么在下一次决策中，**最优决策点 �′\*j\*′** 必定在 �*j* 的后面。

**决策单调性**得证。

#### **【线性规划】**

画出草图：

![img](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_5757575.PNG)

直线 �����*L**i**n**e**i* 的斜率 �0[�]*k*0[*i*] 递增，

由图可知**最优决策点**在递增。

**决策单调性**得证。

#### **【其他】**

从这个角度来看的话，貌似决策单调性和 �(�),�0[�]*X*(*j*),*k*0[*i*] 的单调性是相通的？

于是一个结论就出现了：如果 �(�),�0[�]*X*(*j*),*k*0[*i*] 均单调不减，则该方程必定有**决策单调性**（自己瞎 ��*y**y* 的，不敢肯定一定正确）。

------

## **四.【Code】**

[**【模板】** 玩具装箱 ���*t**o**y* [�3195\][*P*3195]](https://www.luogu.org/problemnew/show/P3195)

这道题 ...... 数据太水了 ...... 我一开始 LL 忘了加 11 居然还过了 ......

```cpp
#include <bits/stdc++.h>

using LL = long long;

const int N = 5e4 + 5;

LL i, j, n, L, hh = 0, tt = -1, q[N], S[N], dp[N];
//S[n]=∑C[i]+1, dp[i]=min(dp[j]+(S[i]-(S[j]+L+1))^2)，++L
//dp[i]=S[i]^2-2*S[i]*L+dp[j]+(S[j]+L)^2-2S[i]*S[j]
//(2*S[i]) * S[j] + (dp[i]-S[i]^2+2S[i]L)=(dp[j]+(S[j]+L)^2)
//   k     *  x   +           b          =        y
LL X(LL j) {return S[j];}
LL Y(LL j) {return dp[j] + (S[j] + L)*(S[j] + L);}
long double slope(LL i, LL j) {return (long double)(Y(j) - Y(i)) / (X(j) - X(i));} //记得开long double

int main() {
    scanf("%lld%lld", &n, &L); ++L;
    for (i = 1; i <= n; S[i] += S[i - 1] + 1, ++i) scanf("%lld", &S[i]);
    q[++tt] = 0; //重中之重
    for (i = 1; i <= n; ++i) {
        while (hh < tt && slope(q[hh], q[hh + 1]) <= 2 * S[i]) hh++; // 这里必须也是while不能是以前的if了
		dp[i] = dp[j = q[hh]] + (S[i] - S[j] - L) * (S[i] - S[j] - L);
		while (hh < tt && slope(q[tt - 1], q[tt]) >= slope(q[tt - 1], i)) --tt;
		q[++tt] = i;
    }
    printf("%lld", dp[n]);
    return 0;
}
```
